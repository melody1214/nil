package object

import (
	"strconv"
	"strings"
	"sync"

	"github.com/chanyoung/nil/pkg/util/uuid"
)

// chunkID is the ID of chunk. It is basically generated by UUID.
type chunkID string

const notFound chunkID = "not found"

// vID is the ID of volume.
type vID string

// egID is the ID of encoding group.
type egID string

// chunk holds the information which are required for object writing.
type chunk struct {
	id            chunkID
	encodingGroup egID
	volume        vID
	encoding      bool
	shard         int

	// Space information.
	size int64
	free int64
}

// newChunkPool returns a new chunk pool with the given configurations.
func newChunkPool(shardSize, chunkSize, chunkHeaderSize, objectHeaderSize, maximumSize int64) *chunkPool {
	return &chunkPool{
		pool:             make(map[chunkID]*chunk),
		writing:          make(map[chunkID]*chunk),
		encoding:         make(map[chunkID]*chunk),
		shardSize:        shardSize,
		chunkSize:        chunkSize,
		chunkHeaderSize:  chunkHeaderSize,
		objectHeaderSize: objectHeaderSize,
		maximumSize:      maximumSize,
	}
}

// chunkPool is the pool of available chunk in the backend store.
type chunkPool struct {
	pool             map[chunkID]*chunk
	writing          map[chunkID]*chunk
	encoding         map[chunkID]*chunk
	shardSize        int64
	chunkSize        int64
	chunkHeaderSize  int64
	objectHeaderSize int64
	maximumSize      int64

	mu sync.Mutex
}

// newChunk creates a new chunk object within the given volume.
func (p *chunkPool) newChunk(encodingGroup egID, volume vID) chunkID {
	cid := chunkID(uuid.Gen())

	p.pool[cid] = &chunk{
		id:            cid,
		volume:        volume,
		encodingGroup: encodingGroup,
		shard:         1,
		size:          p.chunkSize,
		free:          p.chunkSize - p.chunkHeaderSize,
	}

	return cid
}

// FindAvailableChunk returns chunkID which is available for writing.
// This method is never failed, because it will creates a new chunk
// when there is no available chunk.
func (p *chunkPool) FindAvailableChunk(encodingGroup egID, volume vID, writingSize int64) chunkID {
	// TODO: remove volume in parameters.
	// read directly from cmap by using egID.
	p.mu.Lock()
	defer p.mu.Unlock()

	var shard string
	cid := notFound
	for id, c := range p.pool {
		if c.encodingGroup != encodingGroup {
			continue
		}

		if c.free < writingSize {
			continue
		}

		cid = id
		shard = strconv.Itoa(c.shard)
		break
	}

	if cid == notFound {
		cid = p.newChunk(encodingGroup, volume)
		shard = strconv.Itoa(p.pool[cid].shard)
	}

	p.writing[cid] = p.pool[cid]
	delete(p.pool, cid)

	// chunk ID = "cid" + "_" + "shard"
	return chunkID(string(cid) + "_" + shard)
}

// FinishWriting moves chunk with the given id into the other pools.
// If the left free space of the chunk is less than allowed maximum
// chunk size, then push it in the encoding pool. The endec will
// encode it batch. If not, then push int64o the waiting pool to wait
// another writing requests from the clients.
func (p *chunkPool) FinishWriting(cid chunkID, writingSize int64) {
	p.mu.Lock()
	defer p.mu.Unlock()

	cid = chunkID(strings.Split(string(cid), "_")[0])

	c, ok := p.writing[cid]
	if ok == false {
		return
	}
	defer delete(p.writing, cid)

	c.free = c.free - writingSize
	if c.free < p.maximumSize {
		p.pool[cid] = c
		return
	}

	if int64(c.shard) < p.shardSize {
		c.shard++
		c.free = c.size - p.chunkHeaderSize
		p.pool[cid] = c
		return
	}

	p.encoding[cid] = c
}

// GetChunk returns chunk with the given chunk id.
func (p *chunkPool) GetChunk(cid chunkID) (c chunk, ok bool) {
	p.mu.Lock()
	defer p.mu.Unlock()

	cid = chunkID(strings.Split(string(cid), "_")[0])

	for id, c := range p.pool {
		if id == cid {
			return *c, true
		}
	}

	for id, c := range p.writing {
		if id == cid {
			return *c, true
		}
	}

	for id, c := range p.encoding {
		if id == cid {
			return *c, true
		}
	}

	return c, false
}

// GetNeedEncodingChunk returns a chunk object that need to be encoded.
func (p *chunkPool) GetNeedEncodingChunk() (c chunk, ok bool) {
	p.mu.Lock()
	defer p.mu.Unlock()

	for _, chunk := range p.encoding {
		if chunk.encoding {
			continue
		}

		chunk.encoding = true
		return *chunk, true
	}

	return c, false
}

// EncodingFailed set the encoding field to false.
func (p *chunkPool) EncodingFailed(cid chunkID) {
	p.mu.Lock()
	defer p.mu.Unlock()

	for id, chunk := range p.encoding {
		if id != cid {
			continue
		}

		chunk.encoding = false
		return
	}
}

// EncodingSuccess remove chunk with the given id from encoding list.
func (p *chunkPool) EncodingSuccess(cid chunkID) {
	p.mu.Lock()
	defer p.mu.Unlock()

	delete(p.encoding, cid)
}
