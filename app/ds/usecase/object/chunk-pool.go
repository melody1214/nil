package object

import (
	"sync"

	"github.com/chanyoung/nil/pkg/util/uuid"
)

// chunkID is the ID of chunk. It is basically generated by UUID.
type chunkID string

const notFound chunkID = "not found"

// vID is the ID of volume.
type vID string

// chunk holds the information which are required for object writing.
type chunk struct {
	// volume ID.
	id     chunkID
	volume vID

	// Space information.
	size int
	free int
}

// newChunkPool returns a new chunk pool with the given configurations.
func newChunkPool(shardSize, chunkSize, chunkHeaderSize, objectHeaderSize, maximumSize int) *chunkPool {
	return &chunkPool{
		pool:             make(map[chunkID]*chunk),
		writing:          make(map[chunkID]*chunk),
		shardSize:        shardSize,
		chunkSize:        chunkSize,
		chunkHeaderSize:  chunkHeaderSize,
		objectHeaderSize: objectHeaderSize,
		maximumSize:      maximumSize,
	}
}

// chunkPool is the pool of available chunk in the backend store.
type chunkPool struct {
	pool             map[chunkID]*chunk
	writing          map[chunkID]*chunk
	shardSize        int
	chunkSize        int
	chunkHeaderSize  int
	objectHeaderSize int
	maximumSize      int

	mu sync.Mutex
}

// newChunk creates a new chunk object within the given volume.
func (p *chunkPool) newChunk(volume vID) chunkID {
	cid := chunkID(uuid.Gen())

	p.pool[cid] = &chunk{
		id:     cid,
		volume: volume,
		size:   p.chunkSize,
		free:   p.chunkSize - p.chunkHeaderSize,
	}

	return cid
}

// FindAvailableChunk returns chunkID which is available for writing.
// This method is never failed, because it will creates a new chunk
// when there is no available chunk.
func (p *chunkPool) FindAvailableChunk(volume vID, writingSize int) chunkID {
	p.mu.Lock()
	defer p.mu.Unlock()

	cid := notFound
	for id, c := range p.pool {
		if c.volume != volume {
			continue
		}

		if c.free < writingSize {
			continue
		}

		cid = id
		break
	}

	if cid == notFound {
		cid = p.newChunk(volume)
	}

	p.writing[cid] = p.pool[cid]
	delete(p.pool, cid)

	return cid
}

func (p *chunkPool) FinishWriting(cid chunkID, writingSize int64) {
}
