package object

import (
	"sync"

	"github.com/chanyoung/nil/pkg/util/uuid"
)

// chunkID is the ID of chunk. It is basically generated by UUID.
type chunkID string

const notFound chunkID = "not found"

// vID is the ID of volume.
type vID string

// egID is the ID of encoding group.
type egID string

// chunk holds the information which are required for object writing.
type chunk struct {
	// volume ID.
	id            chunkID
	encodingGroup egID
	volume        vID

	// Space information.
	size int64
	free int64
}

// newChunkPool returns a new chunk pool with the given configurations.
func newChunkPool(shardSize, chunkSize, chunkHeaderSize, objectHeaderSize, maximumSize int64) *chunkPool {
	return &chunkPool{
		pool:             make(map[chunkID]*chunk),
		writing:          make(map[chunkID]*chunk),
		encoding:         make(map[chunkID]*chunk),
		shardSize:        shardSize,
		chunkSize:        chunkSize,
		chunkHeaderSize:  chunkHeaderSize,
		objectHeaderSize: objectHeaderSize,
		maximumSize:      maximumSize,
	}
}

// chunkPool is the pool of available chunk in the backend store.
type chunkPool struct {
	pool             map[chunkID]*chunk
	writing          map[chunkID]*chunk
	encoding         map[chunkID]*chunk
	shardSize        int64
	chunkSize        int64
	chunkHeaderSize  int64
	objectHeaderSize int64
	maximumSize      int64

	mu sync.Mutex
}

// newChunk creates a new chunk object within the given volume.
func (p *chunkPool) newChunk(encodingGroup egID, volume vID) chunkID {
	cid := chunkID(uuid.Gen())

	p.pool[cid] = &chunk{
		id:            cid,
		volume:        volume,
		encodingGroup: encodingGroup,
		size:          p.chunkSize,
		free:          p.chunkSize - p.chunkHeaderSize,
	}

	return cid
}

// FindAvailableChunk returns chunkID which is available for writing.
// This method is never failed, because it will creates a new chunk
// when there is no available chunk.
func (p *chunkPool) FindAvailableChunk(encodingGroup egID, volume vID, writingSize int64) chunkID {
	// TODO: remove volume in parameters.
	// read directly from cmap by using egID.
	p.mu.Lock()
	defer p.mu.Unlock()

	cid := notFound
	for id, c := range p.pool {
		if c.encodingGroup != encodingGroup {
			continue
		}

		if c.free < writingSize {
			continue
		}

		cid = id
		break
	}

	if cid == notFound {
		cid = p.newChunk(encodingGroup, volume)
	}

	p.writing[cid] = p.pool[cid]
	delete(p.pool, cid)

	return cid
}

// FinishWriting moves chunk with the given id int64o the other pools.
// If the left free space of the chunk is less than allowed maximum
// chunk size, then push it in the encoding pool. The endec will
// encode it batch. If not, then push int64o the waiting pool to wait
// another writing requests from the clients.
func (p *chunkPool) FinishWriting(cid chunkID, writingSize int64) {
	p.mu.Lock()
	defer p.mu.Unlock()

	c, ok := p.writing[cid]
	if ok == false {
		return
	}

	c.free = c.free - writingSize
	if c.free < p.maximumSize {
		p.pool[cid] = c
	} else {
		p.encoding[cid] = c
	}
	delete(p.writing, cid)
}
